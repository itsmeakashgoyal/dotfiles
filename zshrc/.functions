#!/usr/bin/env bash

# Create a new directory and enter it
function mkd() {
	mkdir -p "$@" && cd "$_";
}

# Determine size of a file or total size of a directory
function fs() {
	if du -b /dev/null > /dev/null 2>&1; then
		local arg=-sbh;
	else
		local arg=-sh;
	fi
	if [[ -n "$@" ]]; then
		du $arg -- "$@";
	else
		du $arg .[^.]* ./*;
	fi;
}

## Function wrappers
# wrapper for easy extraction of compressed files
function extract () {
	if [ -f $1 ] ; then
		case $1 in
			*.tar.xz)    tar xvJf $1    ;;
			*.tar.bz2)   tar xvjf $1    ;;
			*.tar.gz)    tar xvzf $1    ;;
			*.bz2)       bunzip2 $1     ;;
			*.rar)       unrar e $1     ;;
			*.gz)        gunzip $1      ;;
			*.tar)       tar xvf $1     ;;
			*.tbz2)      tar xvjf $1    ;;
			*.tgz)       tar xvzf $1    ;;
			*.apk)       unzip $1       ;;
			*.epub)      unzip $1       ;;
			*.xpi)       unzip $1       ;;
			*.zip)       unzip $1       ;;
			*.war)       unzip $1       ;;
			*.jar)       unzip $1       ;;
			*.Z)         uncompress $1  ;;
			*.7z)        7z x $1        ;;
			*)           echo "don't know how to extract '$1'..." ;;
		esac
	else
		echo "'$1' is not a valid file!"
	fi
}

_fzf_complete_git() {
	_fzf_complete -- "$@" < <(
		git --help -a | grep -E '^\s+' | awk '{print $1}'
	)
}

_fzf_comprun() {
	local command=$1
	shift

	case "$command" in
		tree)         find . -type d | fzf --preview 'tree -C {}' "$@";;
		*)            fzf "$@" ;;
	esac
}

function delete-branches() {
	git branch |
		grep --invert-match '\*' |
		cut -c 3- |
		fzf --multi --preview="git log {} --" |
		xargs --no-run-if-empty git branch --delete --force
}

function delete-remote-branches() {
	git branch -r |
		grep 'akgoyal' |
		grep --invert-match '\*' |
		cut -c 3- |
		fzf --multi --preview="git log {} --" |
		xargs --no-run-if-empty git branch --delete --force
}

function pr-checkout() {
	local jq_template pr_number

	jq_template='"'\
	'#\(.number) - \(.title)'\
	'\t'\
	'Author: \(.user.login)\n'\
	'Created: \(.created_at)\n'\
	'Updated: \(.updated_at)\n\n'\
	'\(.body)'\
	'"'

	pr_number=$(
		gh api 'repos/:owner/:repo/pulls' |
		jq ".[] | $jq_template" |
		sed -e 's/"\(.*\)"/\1/' -e 's/\\t/\t/' |
		fzf \
		--with-nth=1 \
		--delimiter='\t' \
		--preview='echo -e {2}' \
		--preview-window=top:wrap |
		sed 's/^#\([0-9]\+\).*/\1/'
	)

	if [ -n "$pr_number" ]; then
		gh pr checkout "$pr_number"
	fi
}

# navigation
cx() { cd "$@" && l; }
fcd() { cd "$(find . -type d -not -path '*/.*' | fzf)" && l; }
f() { echo "$(find . -type f -not -path '*/.*' | fzf)" | pbcopy }
fv() { nvim "$(find . -type f -not -path '*/.*' | fzf)" }

# turn hidden files on/off in Finder
function hiddenOn() { defaults write com.apple.Finder AppleShowAllFiles YES ; }
function hiddenOff() { defaults write com.apple.Finder AppleShowAllFiles NO ; }

# myIP address
function myip() {
    ifconfig lo0 | grep 'inet ' | sed -e 's/:/ /' | awk '{print "lo0       : " $2}'
    ifconfig en0 | grep 'inet ' | sed -e 's/:/ /' | awk '{print "en0 (IPv4): " $2 " " $3 " " $4 " " $5 " " $6}'
    ifconfig en0 | grep 'inet6 ' | sed -e 's/ / /' | awk '{print "en0 (IPv6): " $2 " " $3 " " $4 " " $5 " " $6}'
    ifconfig en1 | grep 'inet ' | sed -e 's/:/ /' | awk '{print "en1 (IPv4): " $2 " " $3 " " $4 " " $5 " " $6}'
    ifconfig en1 | grep 'inet6 ' | sed -e 's/ / /' | awk '{print "en1 (IPv6): " $2 " " $3 " " $4 " " $5 " " $6}'
}

# Change working directory to the top-most Finder window location
function cdf() { # short for `cdfinder`
	cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')";
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
function targz() {
	local tmpFile="${@%/}.tar";
	tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1;

	size=$(
		stat -f"%z" "${tmpFile}" 2> /dev/null; # macOS `stat`
		stat -c"%s" "${tmpFile}" 2> /dev/null;  # GNU `stat`
	);

	local cmd="";
	if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
		# the .tar file is smaller than 50 MB and Zopfli is available; use it
		cmd="zopfli";
	else
		if hash pigz 2> /dev/null; then
			cmd="pigz";
		else
			cmd="gzip";
		fi;
	fi;

	echo "Compressing .tar ($((size / 1000)) kB) using \`${cmd}\`…";
	"${cmd}" -v "${tmpFile}" || return 1;
	[ -f "${tmpFile}" ] && rm "${tmpFile}";

	zippedSize=$(
		stat -f"%z" "${tmpFile}.gz" 2> /dev/null; # macOS `stat`
		stat -c"%s" "${tmpFile}.gz" 2> /dev/null; # GNU `stat`
	);

	echo "${tmpFile}.gz ($((zippedSize / 1000)) kB) created successfully.";
}

# Use Git’s colored diff when available
hash git &>/dev/null;
if [ $? -eq 0 ]; then
	function diff() {
		git diff --no-index --color-words "$@";
	}
fi;

# Create a data URL from a file
function dataurl() {
	local mimeType=$(file -b --mime-type "$1");
	if [[ $mimeType == text/* ]]; then
		mimeType="${mimeType};charset=utf-8";
	fi
	echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')";
}

# Compare original and gzipped file size
function gz() {
	local origsize=$(wc -c < "$1");
	local gzipsize=$(gzip -c "$1" | wc -c);
	local ratio=$(echo "$gzipsize * 100 / $origsize" | bc -l);
	printf "orig: %d bytes\n" "$origsize";
	printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio";
}

# Show all the names (CNs and SANs) listed in the SSL certificate
# for a given domain
function getcertnames() {
	if [ -z "${1}" ]; then
		echo "ERROR: No domain specified.";
		return 1;
	fi;

	local domain="${1}";
	echo "Testing ${domain}…";
	echo ""; # newline

	local tmp=$(echo -e "GET / HTTP/1.0\nEOT" \
		| openssl s_client -connect "${domain}:443" -servername "${domain}" 2>&1);

	if [[ "${tmp}" = *"-----BEGIN CERTIFICATE-----"* ]]; then
		local certText=$(echo "${tmp}" \
			| openssl x509 -text -certopt "no_aux, no_header, no_issuer, no_pubkey, \
			no_serial, no_sigdump, no_signame, no_validity, no_version");
		echo "Common Name:";
		echo ""; # newline
		echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//" | sed -e "s/\/emailAddress=.*//";
		echo ""; # newline
		echo "Subject Alternative Name(s):";
		echo ""; # newline
		echo "${certText}" | grep -A 1 "Subject Alternative Name:" \
			| sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2;
		return 0;
	else
		echo "ERROR: Certificate not found.";
		return 1;
	fi;
}

# Normalize `open` across Linux, macOS, and Windows.
# This is needed to make the `o` function (see below) cross-platform.
if [ ! $(uname -s) = 'Darwin' ]; then
	if grep -q Microsoft /proc/version; then
		# Ubuntu on Windows using the Linux subsystem
		alias open='explorer.exe';
	else
		alias open='xdg-open';
	fi
fi

# `o` with no arguments opens the current directory, otherwise opens the given
# location
function o() {
	if [ $# -eq 0 ]; then
		open .;
	else
		open "$@";
	fi;
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
	tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}

function pkill() {
  ps aux |
  fzf --height 40% \
      --layout=reverse \
      --header-lines=1 \
      --prompt="Select process to kill: " \
      --preview 'echo {}' \
      --preview-window up:3:hidden:wrap \
      --bind 'F2:toggle-preview' |
  awk '{print $2}' |
  xargs -r bash -c '
      if ! kill "$1" 2>/dev/null; then
          echo "Regular kill failed. Attempting with sudo..."
          sudo kill "$1" || echo "Failed to kill process $1" >&2
      fi
  ' --
}

function cds() {
    session=$(tmux display-message -p '#{session_path}')
    cd "$session"
}

function cfp() {
    local file_path="$1"
    local full_path=$(realpath "$file_path")
    echo -n "$full_path" | xclip -selection clipboard
}

# Function to create and activate a Python virtual environment
function mkvenv() {    # Set the environment directory name, default to 'venv' if no name provided
    local env_dir=${1:-venv}
    local requirements_path="captured-requirements.txt"
    # Check if the environment already exists
    # Create the virtual environment
    echo "Creating new virtual environment '$env_dir'..."
    python3 -m venv $env_dir
    
    # Activate the virtual environment
    source $env_dir/bin/activate
    
    # Optional: Install any default packages
    pip3 install --upgrade pip
    pip3 install wheel

    if [ -f "$requirements_path" ]; then
        echo "Installing packages from '$requirements_path'..."
        pip3 install -r "$requirements_path"
    fi
    
    echo "Virtual environment '$env_dir' created and activated!"
}

function rmvenv() {
    # Check if the environment is active
    local requirements_path="captured-requirements.txt"
    if [[ "$VIRTUAL_ENV" != "" ]]; then
        if [[ ! -f "requirements.txt" ]]; then
            pip3 freeze > "$requirements_path"
        fi
        # Deactivate the environment
        deactivate
        
        echo "Virtual environment deactivated and all installed packages captured"
    else
        echo "No virtual environment is active."
    fi
}

# PROJECT: git-log
function logg() {
    git lg | fzf --ansi --no-sort \
        --preview 'echo {} | grep -o "[a-f0-9]\{7\}" | head -1 | xargs -I % git show % --color=always' \
        --preview-window=right:50%:wrap --height 100% \
        --bind 'enter:execute(echo {} | grep -o "[a-f0-9]\{7\}" | head -1 | xargs -I % sh -c "git show % | nvim -c \"setlocal buftype=nofile bufhidden=wipe noswapfile nowrap\" -c \"nnoremap <buffer> q :q!<CR>\" -")' \
        --bind 'ctrl-e:execute(echo {} | grep -o "[a-f0-9]\{7\}" | head -1 | xargs -I % sh -c "gh browse %")' \
}

# xev wrapper for ascii keycodes
function char2hex() {
    xev | awk -F'[ )]+' '/^KeyPress/ { a[NR+2] } NR in a { printf "%-3s %s\n", $5, $8 }'
}

# Creates a folder named with the current or prefixed date, using the format "prefix-YYYY-MM-DD" if a prefix is provided.
function mkdd ()
{
    mkdir -p ${1:+$1$prefix_separator}"$(date +%F)";
}

# Creates a real-time countdown with alert sound, useful for bash scripts and terminal.
function timer ()
{
    total=$1 
    for ((i=total; i>0; i--)); do sleep 1; printf "Time remaining %s secs \r" "$i"; done
    echo -e "\a" 
}

# Display calendar with day highlighted
function cal ()
{
    if [ -t 1 ] ; then alias cal="ncal -b" ; else alias cal="/usr/bin/cal" ; fi
}

# Simplifies font installation, making font customization easier and improving visual experience in the shell
function install_font ()
{
    if [[ -z $1 ]]; then
    echo provide path to zipped font file 
    return 1
    fi
    
    font_zip=$(realpath "$1")

    unzip "$font_zip" "*.ttf" "*.otf" -d ~/.local/share/fonts/
    fc-cache -vf
}

# Common function to search for a string in files using rga and fzf, and opens the file with nvim.
function _fif_common() {
    local ignore_case_flag="$1"
    shift

    local files
    local preview_cmd=$(printf "rga %s --pretty --context 10 '%s' {}" "$ignore_case_flag" "$*")
    local rga_output=$(rga --max-count=1 $ignore_case_flag --files-with-matches --no-messages "$*")
    # PROJECT: project
    # This is used to copy file names so that they can be used a project documentaiton
    echo "$rga_output" | xsel --clipboard --input
    IFS=$'\n' files=($(echo "$rga_output" | fzf-tmux +m --preview="$preview_cmd" --multi --select-1 --exit-0)) || return 1

    if [ ${#files[@]} -eq 0 ]; then
        echo "No files selected."
        return 0
    fi

    typeset -a temp_files
    for i in {1..${#files[@]}}; do
        if [[ -n "${files[i]}" ]]; then
        temp_files[i]=$(realpath "${files[i]}")
        fi
    done
    files=("${temp_files[@]}")
    local nvim_cmd=""
    case "${#files[@]}" in
        2)
        nvim -O "${files[1]}" "${files[2]}"
        ;;
        3)
        nvim_cmd="nvim -O \"${files[1]}\" -c 'wincmd j' -c \"vsplit ${files[2]}\" -c \"split ${files[3]}\""
        ;;
        4)
        nvim_cmd="nvim -O \"${files[1]}\" -c \"vsplit ${files[2]}\" -c \"split ${files[3]}\" -c 'wincmd h' -c \"split ${files[4]}\""
        ;;
        *)
        nvim_cmd="nvim \"${files[@]}\""
        ;;
    esac

    eval "$nvim_cmd"
}

# Wrapper function for case-sensitive search
function fifs() {
    _fif_common "" "$@"
}

# Wrapper function for case-insensitive search
function fif() {
    _fif_common "--ignore-case" "$@"
}

# Add all changes to git, commit with given message, and push
function gac() {
    git add .
    git commit -m "$1"
    git push
}

# Add all changes to git, commit with given message and signed-off-by line, and push
function gacs() {
    git add .
    git commit -m "$1" -s
    git push
}

# Find a repo for authenticated user with gh CLI and cd into it, clone and cd if not found on disk
function repo() {
    export repo=$(fd . ${HOME}/dev --type=directory --max-depth=1 --color always| awk -F "/" '{print $5}' | fzf --ansi --preview 'onefetch /home/decoder/dev/{1}' --preview-window up)
    if [[ -z "$repo" ]]; then
        echo "Repository not found"
    else
        echo "Repository found locally, entering"
        cd ${HOME}/dev/$repo
        if [[ -d .git ]]; then
            echo "Fetching origin"
            git fetch origin
            onefetch
        fi
            create_tmux_session "${HOME}/dev/$repo"
    fi
}

function create_tmux_session() {
    local RESULT="$1"
    zoxide add "$RESULT" &>/dev/null
    local FOLDER=$(basename "$RESULT")
    local SESSION_NAME=$(echo "$FOLDER" | tr ' .:' '_')
    
    if [ -d "$RESULT/.git" ]; then
        SESSION_NAME+="_$(git -C "$RESULT" symbolic-ref --short HEAD 2>/dev/null)"
    fi
    
    if ! tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
        tmux new-session -d -s "$SESSION_NAME" -c "$RESULT"
    fi
    
    if [ -z "$TMUX" ]; then
        tmux attach -t "$SESSION_NAME"
    else
        tmux switch-client -t "$SESSION_NAME"
    fi
}

# Check system info using onefetch and output in terminal
function checkfetch() {
    local res=$(onefetch) &> /dev/null
    if [[ "$res" =~ "Error" ]]; then
        echo ""
    else echo $(onefetch)
    fi
}

function open_file_git_staged() {
    ~/dotfiles-dev/scripts/_open-file-git-staged.sh 
}

# Binds Ctrl+Alt+O to open_file_git
bindkey "^[^O" open_file_git_staged
zle -N open_file_git_staged

function zoxider() {
    BUFFER=$(zoxide query -i)
    zle accept-line
}

zle -N zoxider
bindkey '^[j' zoxider

function f_git_enter() {
    BUFFER="~/dotfiles-dev/scripts/_open-file-git.sh"
    zle accept-line
}

zle -N f_git_enter
bindkey '^o' f_git_enter

copy-line-to-clipboard() {
    echo -n $BUFFER | xclip -selection clipboard
}
zle -N copy-line-to-clipboard
bindkey '^Y' copy-line-to-clipboard
